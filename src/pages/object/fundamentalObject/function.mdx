import { Note } from '@/components/callout';

# Function objects


## Function Prototype Object


### Function.prototype.apply

```ts
Function.prototype.apply(thisArg, argArray)
```

apply方法执行以下步骤：

<Note>
1. Let *func* be the **this** value.
2. If *IsCallable(func)* is **false**, throw a **TypeError** exception.
3. If *argArray* is either *undefined* or *null*, then
  a. Perform [PrepareForTailCall()](/grammar/functionClass#preparefortailcall).
  b. Return ? *Call(func, thisArg)*.
4. Let *argList* be ? *CreateListFromArrayLike(argArray)*.
5. Perform *PrepareForTailCall()*.
6. Return ? *Call(func, thisArg, argList)*.
</Note>

实现polyfill

```ts
export function apply(this: Function, thisArg: any, arrArray: any): any {

  let ctx: CtxType;
  const func = this;

  if(!IsCallable(func)) throw new TypeError('caller must be a function');

  if(isNullOrUndefined(thisArg)) {
    ctx = globalObject
  }else {
    ctx = toObject(thisArg)
  }

  ctx['func'] = func;

  // perform PrepareForTailCall

  if(isNullOrUndefined(arrArray)) {
    arrArray = []
  }

  const result = ctx.func(...arrArray);

  delete ctx['func'];

  return result
}
```

### Function.prototype.call

```ts
Function.prototype.call ( thisArg, ...args )
```

call方法执行以下步骤：

```md
1. Let func be the this value.
2. If IsCallable(func) is false, throw a TypeError exception.
3. Perform PrepareForTailCall().
4. Return ? Call(func, thisArg, args).
```

实现polyfill, 源码[传送门]()

```ts
interface CtxType {
  [key: string]: any
}

export default function call(this: Function, thisArg: LanguageType, args: LanguageType[]): any {

  let ctx: CtxType;
  const func = this;

  if(!IsCallable(func)) throw new TypeError('func must be a function');

  if(isNullOrUndefined(thisArg)) {
    ctx = globalObject
  }else {
    ctx = toObject(thisArg)
  }

  ctx['func'] = func;

  // Perform PrepareForTailCall
  const result =  ctx.func(...args);

  // delete ctx['func'];
  delete ctx['func'];

  return result;
}


```


<Note>
  Note1
  thisArg作为`this`参数没有被修改的传递，如果*thisArg*为`null`或者`undefined`，则用**globalObject**
  代替，其他类型的值则通过*toObject*来转换。
  非严格模式下仍旧进行这些转换
</Note>

<Note>
  Note2
  如果func是**箭头函数或者bound function**，则 *thisArg* 则会忽略
</Note>


